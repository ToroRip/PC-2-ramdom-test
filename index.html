<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Battle Royale Random Selector</title>
  <style>
    :root {
      --bg: #0f1115;
      --panel: #141824;
      --panel2: #101421;
      --text: #e8eefc;
      --muted: #a8b3d6;
      --line: rgba(255,255,255,0.08);
      --good: #5bc0ff;
      --bad: #ff6b6b;
      --warn: #ffd166;
      --ok: #8aff80;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: radial-gradient(1200px 800px at 20% 10%, #1a2140 0%, var(--bg) 55%);
      color: var(--text);
    }
    header {
      padding: 18px 18px 10px;
      border-bottom: 1px solid var(--line);
      display: flex;
      gap: 14px;
      align-items: baseline;
      justify-content: space-between;
    }
    header h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: 0.2px;
    }
    header .sub {
      color: var(--muted);
      font-size: 12px;
    }
    main {
      display: grid;
      grid-template-columns: 420px 1fr;
      gap: 14px;
      padding: 14px 18px 18px;
    }
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.015));
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 18px 40px rgba(0,0,0,0.35);
    }
    .card h2 {
      margin: 0 0 10px;
      font-size: 13px;
      color: var(--muted);
      font-weight: 600;
      letter-spacing: 0.2px;
      text-transform: uppercase;
    }
    label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin: 10px 0 6px;
    }
    input, textarea, select, button {
      width: 100%;
      background: rgba(0,0,0,0.25);
      border: 1px solid var(--line);
      color: var(--text);
      border-radius: 10px;
      padding: 10px 10px;
      font-size: 14px;
      outline: none;
    }
    textarea { min-height: 90px; resize: vertical; }
    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .btnrow { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
    button {
      cursor: pointer;
      border: 1px solid rgba(255,255,255,0.14);
      background: linear-gradient(180deg, rgba(91,192,255,0.16), rgba(91,192,255,0.06));
    }
    button.secondary {
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
    }
    button.danger {
      background: linear-gradient(180deg, rgba(255,107,107,0.18), rgba(255,107,107,0.06));
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .list {
      border: 1px solid var(--line);
      border-radius: 12px;
      overflow: hidden;
      margin-top: 10px;
    }
    .list .head {
      display: flex;
      justify-content: space-between;
      padding: 10px 10px;
      background: rgba(255,255,255,0.03);
      border-bottom: 1px solid var(--line);
      font-size: 12px;
      color: var(--muted);
    }
    .list .items {
      max-height: 240px;
      overflow: auto;
    }
    .item {
      display: grid;
      grid-template-columns: 1fr 90px;
      gap: 10px;
      padding: 9px 10px;
      border-bottom: 1px solid var(--line);
      align-items: center;
    }
    .item:last-child { border-bottom: none; }
    .item .name { font-size: 13px; }
    .tag {
      font-size: 11px;
      color: var(--muted);
      border: 1px solid var(--line);
      padding: 4px 8px;
      border-radius: 999px;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .canvasWrap {
      position: relative;
      height: 560px;
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid var(--line);
      background: radial-gradient(900px 500px at 20% 20%, rgba(91,192,255,0.12), rgba(0,0,0,0) 60%),
                  radial-gradient(700px 400px at 80% 60%, rgba(255,107,107,0.10), rgba(0,0,0,0) 60%),
                  linear-gradient(180deg, rgba(255,255,255,0.03), rgba(0,0,0,0.0));
    }
    canvas { width: 100%; height: 100%; display: block; }
    .hud {
      position: absolute;
      left: 12px;
      top: 12px;
      right: 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      pointer-events: none;
    }
    .pill {
      pointer-events: none;
      display: inline-flex;
      gap: 10px;
      align-items: center;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,0.25);
      color: var(--text);
      font-size: 12px;
      backdrop-filter: blur(6px);
    }
    .pill span { color: var(--muted); }
    .log {
      margin-top: 10px;
      border: 1px solid var(--line);
      border-radius: 12px;
      overflow: hidden;
    }
    .log pre {
      margin: 0;
      padding: 10px;
      max-height: 240px;
      overflow: auto;
      background: rgba(0,0,0,0.25);
      font-size: 12px;
      color: #d7e1ff;
      line-height: 1.35;
      white-space: pre-wrap;
    }
    .foot {
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
    }
    @media (max-width: 980px) {
      main { grid-template-columns: 1fr; }
      .canvasWrap { height: 520px; }
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Battle Royale Random Selector</h1>
      <div class="sub">No pairing bracket — everyone participates each round, eliminations until winners remain.</div>
    </div>
    <div class="sub">Single-file HTML • Canvas animation</div>
  </header>

  <main>
    <section class="card">
      <h2>Input</h2>

      <label>Group name</label>
      <input id="groupName" placeholder="e.g., Team A" />

      <label>Names (comma-separated)</label>
      <textarea id="namesText" placeholder="Alice, Bob, Charlie"></textarea>

      <div class="btnrow">
        <button id="addBtn">Add people</button>
        <button id="clearBtn" class="danger">Clear all</button>
      </div>

      <div class="list">
        <div class="head">
          <div><b id="countLabel">0</b> people</div>
          <div class="sub">Click a row to remove</div>
        </div>
        <div id="peopleList" class="items"></div>
      </div>

      <h2 style="margin-top:14px;">Selection</h2>

      <div class="row">
        <div>
          <label>Mode</label>
          <select id="modeSel">
            <option value="fight">fight (HP battle)</option>
            <option value="race">race (distance)</option>
            <option value="random" selected>random (per round)</option>
          </select>
        </div>
        <div>
          <label>Winners</label>
          <input id="winnersNum" type="number" min="1" value="1" />
        </div>
      </div>

      <div class="row">
        <div>
          <label>Seed (optional)</label>
          <input id="seedText" placeholder="leave blank for random" />
        </div>
        <div>
          <label>Eliminate % per round</label>
          <input id="elimPct" type="number" min="5" max="80" value="25" />
        </div>
      </div>

      <div class="btnrow">
        <button id="startBtn">Start</button>
        <button id="stopBtn" class="secondary" disabled>Stop</button>
      </div>

      <div class="log">
        <pre id="logBox"></pre>
      </div>

      <div class="foot">
        Tips: Use <b>random</b> mode for mixed rounds. Increase eliminate% to finish faster.
      </div>
    </section>

    <section class="card">
      <h2>Arena</h2>
      <div class="canvasWrap">
        <div class="hud">
          <div class="pill" id="hudLeft"><span>Status:</span> idle</div>
          <div class="pill" id="hudRight"><span>Alive:</span> 0 <span>Target:</span> 0</div>
        </div>
        <canvas id="arena"></canvas>
      </div>
    </section>
  </main>

<script>
/* -----------------------------
   Utilities: RNG with seed
----------------------------- */
function xmur3(str) {
  let h = 1779033703 ^ str.length;
  for (let i = 0; i < str.length; i++) {
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function() {
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    h ^= (h >>> 16);
    return h >>> 0;
  };
}
function sfc32(a, b, c, d) {
  return function() {
    a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;
    let t = (a + b) | 0;
    a = b ^ (b >>> 9);
    b = (c + (c << 3)) | 0;
    c = (c << 21) | (c >>> 11);
    d = (d + 1) | 0;
    t = (t + d) | 0;
    c = (c + t) | 0;
    return (t >>> 0) / 4294967296;
  };
}
function makeRng(seedText) {
  if (!seedText) return Math.random;
  const seed = xmur3(seedText);
  return sfc32(seed(), seed(), seed(), seed());
}
function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
function lerp(a, b, t) { return a + (b - a) * t; }
function choice(rng, arr) { return arr[Math.floor(rng() * arr.length)]; }

/* -----------------------------
   App state
----------------------------- */
const people = []; // {name, group, id}
let nextId = 1;

const ui = {
  groupName: document.getElementById("groupName"),
  namesText: document.getElementById("namesText"),
  addBtn: document.getElementById("addBtn"),
  clearBtn: document.getElementById("clearBtn"),
  list: document.getElementById("peopleList"),
  countLabel: document.getElementById("countLabel"),
  modeSel: document.getElementById("modeSel"),
  winnersNum: document.getElementById("winnersNum"),
  seedText: document.getElementById("seedText"),
  elimPct: document.getElementById("elimPct"),
  startBtn: document.getElementById("startBtn"),
  stopBtn: document.getElementById("stopBtn"),
  logBox: document.getElementById("logBox"),
  hudLeft: document.getElementById("hudLeft"),
  hudRight: document.getElementById("hudRight"),
  canvas: document.getElementById("arena"),
};

function log(line) {
  ui.logBox.textContent += line + "\n";
  ui.logBox.scrollTop = ui.logBox.scrollHeight;
}
function clearLog() { ui.logBox.textContent = ""; }

function normalizeName(s) { return (s || "").trim(); }
function normalizeKey(name, group) {
  return `${name}`.trim().toLowerCase() + "||" + `${group}`.trim().toLowerCase();
}
function renderList() {
  ui.list.innerHTML = "";
  ui.countLabel.textContent = people.length;
  for (const p of people) {
    const row = document.createElement("div");
    row.className = "item";
    row.title = "Click to remove";
    row.innerHTML = `<div class="name">${escapeHtml(p.name)}</div><div class="tag">${escapeHtml(p.group)}</div>`;
    row.onclick = () => {
      const idx = people.findIndex(x => x.id === p.id);
      if (idx >= 0) people.splice(idx, 1);
      renderList();
    };
    ui.list.appendChild(row);
  }
}
function escapeHtml(s) {
  return (s ?? "").replace(/[&<>"']/g, c => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
  }[c]));
}

/* -----------------------------
   Adding people
----------------------------- */
ui.addBtn.onclick = () => {
  const group = normalizeName(ui.groupName.value);
  const namesRaw = ui.namesText.value || "";
  if (!group) { alert("Please enter a group name."); return; }
  const names = namesRaw.split(",").map(normalizeName).filter(Boolean);
  if (!names.length) { alert("Please enter at least 1 name (comma-separated)."); return; }

  // add + dedupe
  const existing = new Set(people.map(p => normalizeKey(p.name, p.group)));
  let added = 0;
  for (const n of names) {
    const k = normalizeKey(n, group);
    if (existing.has(k)) continue;
    people.push({ name: n, group, id: nextId++ });
    existing.add(k);
    added++;
  }

  ui.namesText.value = "";
  renderList();
  log(`Added ${added} people to "${group}". Total: ${people.length}`);
};

ui.clearBtn.onclick = () => {
  if (!people.length) return;
  if (!confirm("Clear all people?")) return;
  people.length = 0;
  renderList();
  clearLog();
  log("Cleared all people.");
};

/* -----------------------------
   Arena simulation (Battle Royale)
----------------------------- */
const ctx = ui.canvas.getContext("2d");
let raf = null;
let running = false;

let rng = Math.random;
let alive = [];       // {name, group, id, hp, hpDisp, dist, distDisp, eliminated, colorIdx}
let winnersTarget = 1;
let roundMode = "fight";
let userMode = "random";
let round = 1;

let roundTicks = 0;
let roundTicksLimit = 420; // ~7s at 60fps
let elimCountThisRound = 1;
let elimPct = 0.25;

const palette = [
  {fill:"#5bc0ff", dim:"#2b6e9a"},
  {fill:"#ff6b6b", dim:"#8f2f2f"},
  {fill:"#ffd166", dim:"#8a6a1f"},
  {fill:"#8aff80", dim:"#2b7a2f"},
  {fill:"#b388ff", dim:"#5a3a8a"},
  {fill:"#ff8ad4", dim:"#8a3a6b"},
];

const floatTexts = []; // {x,y,vx,vy,life,txt,color}

function resizeCanvasToCss() {
  const rect = ui.canvas.getBoundingClientRect();
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  ui.canvas.width = Math.floor(rect.width * dpr);
  ui.canvas.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener("resize", resizeCanvasToCss);

function setHud(status) {
  ui.hudLeft.textContent = `Status: ${status}`;
  ui.hudRight.textContent = `Alive: ${alive.length}  Target: ${winnersTarget}  Round: ${round}  Mode: ${roundMode}`;
}

function pickRoundMode() {
  if (userMode === "random") return choice(rng, ["fight", "race"]);
  return userMode;
}

function computeElimCount() {
  const n = alive.length;
  const target = winnersTarget;
  const base = Math.max(1, Math.floor(n * elimPct));
  let elim = base;
  if (n - elim < target) elim = n - target;
  elim = Math.max(1, elim);
  return elim;
}

function startSim() {
  if (people.length < 2) { alert("Add at least 2 people."); return; }

  winnersTarget = clamp(parseInt(ui.winnersNum.value || "1", 10), 1, people.length);
  userMode = ui.modeSel.value;
  const seed = (ui.seedText.value || "").trim();
  rng = makeRng(seed);
  elimPct = clamp((parseInt(ui.elimPct.value || "25", 10) / 100), 0.05, 0.8);

  // init alive
  alive = people.map((p, i) => ({
    name: p.name,
    group: p.group,
    id: p.id,
    hp: 100,
    hpDisp: 100,
    dist: 0,
    distDisp: 0,
    eliminated: false,
    colorIdx: i % palette.length,
  }));

  round = 1;
  roundMode = pickRoundMode();
  roundTicks = 0;
  roundTicksLimit = (roundMode === "fight") ? 420 : 360; // fight slightly longer
  elimCountThisRound = computeElimCount();

  floatTexts.length = 0;

  clearLog();
  log(`ROUND ${round} begins — mode=${roundMode.toUpperCase()} | alive=${alive.length} | eliminate=${elimCountThisRound}`);

  running = true;
  ui.startBtn.disabled = true;
  ui.stopBtn.disabled = false;
  setHud("running");

  resizeCanvasToCss();
  loop();
}

function stopSim() {
  running = false;
  ui.startBtn.disabled = false;
  ui.stopBtn.disabled = true;
  setHud("stopped");
  if (raf) cancelAnimationFrame(raf);
  raf = null;
}

ui.startBtn.onclick = startSim;
ui.stopBtn.onclick = stopSim;

function endRound() {
  // eliminate bottom performers
  if (alive.length <= winnersTarget) return;

  let eliminated = [];
  if (roundMode === "fight") {
    const ranked = [...alive].sort((a,b) => (a.hp - b.hp) || (rng() - 0.5));
    eliminated = ranked.slice(0, elimCountThisRound);
  } else {
    const ranked = [...alive].sort((a,b) => (a.dist - b.dist) || (rng() - 0.5));
    eliminated = ranked.slice(0, elimCountThisRound);
  }

  const elimIds = new Set(eliminated.map(p => p.id));
  for (const p of eliminated) {
    log(`Eliminated: ${p.name} (${p.group}) | ${roundMode==="fight" ? "HP="+p.hp : "Dist="+p.dist}`);
    // floating text
    floatTexts.push({
      x: 50 + rng()*200,
      y: 70 + rng()*120,
      vx: -0.2 + rng()*0.4,
      vy: -0.8 - rng()*0.6,
      life: 90,
      txt: "ELIMINATED",
      color: "#ff6b6b",
    });
  }
  alive = alive.filter(p => !elimIds.has(p.id));

  if (alive.length <= winnersTarget) {
    log("");
    log("FINAL WINNERS:");
    alive.forEach((p, idx) => log(`${idx+1}. ${p.name} (${p.group})`));
    setHud("completed");
    stopSim();
    return;
  }

  // next round
  round++;
  roundMode = pickRoundMode();
  roundTicks = 0;
  roundTicksLimit = (roundMode === "fight") ? 420 : 360;
  elimCountThisRound = computeElimCount();

  // reset per-round stats (round-based vibe)
  for (const p of alive) {
    p.hp = 100; p.hpDisp = 100;
    p.dist = 0; p.distDisp = 0;
  }

  log("");
  log(`ROUND ${round} begins — mode=${roundMode.toUpperCase()} | alive=${alive.length} | eliminate=${elimCountThisRound}`);
}

function fightTick() {
  if (alive.length < 2) return;

  // hits per frame based on crowd size
  const n = alive.length;
  const hits = (n < 8) ? 1 : (n < 18) ? 2 : 3;

  for (let i = 0; i < hits; i++) {
    const attacker = alive[Math.floor(rng() * alive.length)];
    let target = alive[Math.floor(rng() * alive.length)];
    if (target.id === attacker.id) continue;

    const dmg = 3 + Math.floor(rng() * 10); // 3..12
    target.hp = Math.max(0, target.hp - dmg);

    // float text
    floatTexts.push({
      x: 0, y: 0, vx: -0.2 + rng()*0.4, vy: -1.2 - rng()*0.8,
      life: 50, txt: `-${dmg}`, color: "#ffd166"
    });
    // We'll position float text near the target in render() based on last hit cache
    target._lastHit = dmg;
    target._lastHitT = 12;
  }
}

function raceTick() {
  for (const p of alive) {
    p.dist = Math.min(100, p.dist + Math.floor(rng() * 4)); // 0..3
  }
}

function updateSmooth() {
  for (const p of alive) {
    if (roundMode === "fight") {
      p.hpDisp = lerp(p.hpDisp, p.hp, 0.12);
    } else {
      p.distDisp = lerp(p.distDisp, p.dist, 0.14);
    }
    if (p._lastHitT) p._lastHitT--;
  }
  for (const ft of floatTexts) {
    ft.x += ft.vx;
    ft.y += ft.vy;
    ft.life -= 1;
  }
  // remove dead float texts
  for (let i = floatTexts.length - 1; i >= 0; i--) {
    if (floatTexts[i].life <= 0) floatTexts.splice(i, 1);
  }
}

function draw() {
  const w = ui.canvas.clientWidth;
  const h = ui.canvas.clientHeight;
  ctx.clearRect(0,0,w,h);

  // background glow
  ctx.fillStyle = "rgba(0,0,0,0.15)";
  ctx.fillRect(0,0,w,h);

  // Title line
  ctx.fillStyle = "rgba(232,238,252,0.9)";
  ctx.font = "600 13px ui-sans-serif, system-ui";
  ctx.fillText(`Round ${round} — ${roundMode.toUpperCase()} — Alive: ${alive.length} — Eliminating: ${elimCountThisRound}`, 16, 32);

  // Layout bars
  const top = 52;
  const left = 16;
  const right = w - 16;
  const barLeft = left + 260;
  const barRight = right - 16;
  const barW = Math.max(140, barRight - barLeft);

  const n = alive.length || 1;
  const rowH = clamp(Math.floor((h - top - 22) / n), 22, 42);

  // sort stable (group, name)
  const ordered = [...alive].sort((a,b) => {
    const g = a.group.toLowerCase().localeCompare(b.group.toLowerCase());
    if (g) return g;
    return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
  });

  let y = top;

  // Track finish line for race
  if (roundMode === "race") {
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(barRight, top);
    ctx.lineTo(barRight, h-12);
    ctx.stroke();
  }

  for (const p of ordered) {
    const pal = palette[p.colorIdx];

    // name
    ctx.fillStyle = "rgba(232,238,252,0.92)";
    ctx.font = "500 12px ui-sans-serif, system-ui";
    ctx.fillText(p.name, left, y + rowH * 0.70);

    ctx.fillStyle = "rgba(168,179,214,0.9)";
    ctx.font = "500 11px ui-sans-serif, system-ui";
    ctx.fillText(`[${p.group}]`, left + 140, y + rowH * 0.70);

    // bar bg
    const by = y + 6;
    const bh = rowH - 12;
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    roundRect(barLeft, by, barW, bh, 8);
    ctx.fill();

    // bar fill
    let pct = 0;
    let label = "";
    if (roundMode === "fight") {
      pct = clamp(p.hpDisp / 100, 0, 1);
      label = `${Math.round(p.hpDisp)}/100 HP`;
    } else {
      pct = clamp(p.distDisp / 100, 0, 1);
      label = `${Math.round(p.distDisp)}/100 m`;
    }

    ctx.fillStyle = pal.fill;
    roundRect(barLeft, by, Math.max(0, barW * pct), bh, 8);
    ctx.fill();

    // bar outline
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.lineWidth = 1;
    roundRect(barLeft, by, barW, bh, 8);
    ctx.stroke();

    // value label
    ctx.fillStyle = "rgba(232,238,252,0.9)";
    ctx.font = "600 11px ui-sans-serif, system-ui";
    ctx.fillText(label, barLeft + barW - 8 - ctx.measureText(label).width, y + rowH * 0.70);

    // last hit flash
    if (roundMode === "fight" && p._lastHitT && p._lastHit) {
      const alpha = clamp(p._lastHitT / 12, 0, 1);
      ctx.fillStyle = `rgba(255, 209, 102, ${0.20 * alpha})`;
      ctx.fillRect(barLeft, by, barW, bh);

      // spawn floating text near this bar (reusing pool)
      if (p._lastHitT === 11) {
        floatTexts.push({
          x: barLeft + barW * pct + 8,
          y: by + bh * 0.6,
          vx: -0.1 + rng()*0.2,
          vy: -1.2 - rng()*0.6,
          life: 48,
          txt: `-${p._lastHit}`,
          color: "#ffd166"
        });
      }
    }

    y += rowH;
  }

  // floating texts
  ctx.font = "700 12px ui-sans-serif, system-ui";
  for (const ft of floatTexts) {
    const alpha = clamp(ft.life / 50, 0, 1);
    ctx.fillStyle = withAlpha(ft.color, alpha);
    ctx.fillText(ft.txt, ft.x, ft.y);
  }
}

function withAlpha(hex, a) {
  // hex like #rrggbb -> rgba
  const r = parseInt(hex.slice(1,3), 16);
  const g = parseInt(hex.slice(3,5), 16);
  const b = parseInt(hex.slice(5,7), 16);
  return `rgba(${r},${g},${b},${a})`;
}

function roundRect(x, y, w, h, r) {
  r = Math.min(r, h/2, w/2);
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}

function loop() {
  if (!running) return;

  // simulate
  roundTicks++;
  if (roundMode === "fight") fightTick();
  else raceTick();

  updateSmooth();
  draw();
  setHud("running");

  // end round by time
  if (roundTicks >= roundTicksLimit) {
    endRound();
  }

  raf = requestAnimationFrame(loop);
}

/* Init */
renderList();
resizeCanvasToCss();
setHud("idle");
log("Add people, choose mode + winners, then Start.");
</script>
</body>
</html>
